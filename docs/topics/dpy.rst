.. _dpy:

===============
Python fixtures
===============

**Python fixtures** are one of the important concepts which Lino adds
to a Django project. They are used (1) to write demonstrative data
samples for application prototypes and test suites and (2) to make
backups and data migrations.

You know that a *fixture* is a portion of data (a collection of data
records in one or several tables) which can be loaded into a database.
Read more about fixtures in the `Providing initial data for models
<https://docs.djangoproject.com/en/dev/howto/initial-data/>`_ article
of the Django documentation.  This article says that "fixtures can be
written as XML, YAML, or JSON documents".  Well, Lino adds another
format to this list: Python.  

Here is a fictive minimal example of a Python fixture::

  from myapp.models import Foo
  def objects():
      yield Foo(name="First")
      yield Foo(name="Second")

A Python fixture is syntactically a normal Python module, stored in a
file ending with `.py` and designed to being imported and exectued
during Django's `loaddata
<https://docs.djangoproject.com/en/dev/ref/django-admin/#django-admin-loaddata>`_
command.


How it works
------------
  
When a Lino application starts up, it sets your `SERIALIZATION_MODULES
<https://docs.djangoproject.com/en/dev/ref/settings/#serialization-modules>`_
setting to `{"py" : "lino.utils.dpy"}`.  This tells Django to
associate the `.py` ending to the :class:`lino.utils.dpy.Deserializer`
class when loading ("deserializing") fixtures.

The :class:`lino.utils.dpy.Deserializer` expects every Python fixture
to define a global function `objects` which it expects to return (or
`yield
<http://stackoverflow.com/questions/231767/the-python-yield-keyword-explained>`_)
the list of model instances to be added to the database.

Vocabulary:

- a *serializer* is run by the 
  `dumpdata <https://docs.djangoproject.com/en/dev/ref/django-admin/#dumpdata-appname-appname-appname-model>`_ 
  command and 
  dumps data into a file which can be  used as a fixture.
  
- a *deserializer* is run by 
  `loaddata <https://docs.djangoproject.com/en/dev/ref/django-admin/#django-admin-loaddata>`_ 
  and loads fixtures into the database.
  
  
Note that you cannot use relative imports in a Python fixture.
See `here 
<http://stackoverflow.com/questions/4907054/loading-each-py-file-in-a-path-imp-load-module-complains-about-relative-impor>`__


"Dumped" and "intelligent" fixtures
-----------------------------------

Note the difference between "intelligent" and "dumped" fixtures:

- An **intelligent fixture** is written by a human. 
  You use them to provide demo data to a Lino application.

- A **dumped fixture** is generated by the `dumpdata` command and looks much 
  less readable because it is optimized to allow automated database 
  migrations.
  
 
Discussion
----------
  
Concept and implementation of Python fixtures is fully the author's
work, and we didn't yet find a similar approach in any other
framework.  But the basic idea of using Python language to describe
data collections is of course not new.

- For example Limodou published a Djangosnippet in 2007 which does
  something similar: `db_dump.py - for dumpping and loading data from
  database <http://djangosnippets.org/snippets/14/>`_.

- http://code.djangoproject.com/ticket/10664

